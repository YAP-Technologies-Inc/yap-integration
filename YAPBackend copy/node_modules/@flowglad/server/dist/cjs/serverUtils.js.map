{"version":3,"sources":["../../src/serverUtils.ts"],"sourcesContent":["import {\n  CoreCustomerUser,\n  FlowgladServerSessionParams,\n  NextjsAuthFlowgladServerSessionParams,\n  SupabaseFlowgladServerSessionParams,\n} from './types'\n\nexport const getSessionFromNextAuth = async (\n  params: NextjsAuthFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.nextAuth.auth()\n  if (session?.user) {\n    if (params.nextAuth.customerFromAuth) {\n      coreCustomerUser =\n        await params.nextAuth.customerFromAuth(session)\n    } else if (!session.user.email) {\n      throw new Error(\n        'FlowgladError: NextAuth session has no email. Please provide an extractUserIdFromSession function to extract the userId from the session, or include email on your sessions.'\n      )\n    } else {\n      coreCustomerUser = {\n        externalId: session.user.email,\n        name: session.user.name || '',\n        email: session.user.email || '',\n      }\n    }\n  }\n  return coreCustomerUser\n}\n\nexport const sessionFromSupabaseAuth = async (\n  params: SupabaseFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const {\n    data: { user },\n  } = await (await params.supabaseAuth.client()).auth.getUser()\n  if (user) {\n    coreCustomerUser = {\n      externalId: user.id,\n      name: user.user_metadata.name || '',\n      email: user.email || '',\n    }\n  }\n  return coreCustomerUser\n}\n\nexport const getSessionFromParams = async (\n  params: FlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  if ('nextAuth' in params) {\n    coreCustomerUser = await getSessionFromNextAuth(params)\n  }\n\n  if ('supabaseAuth' in params) {\n    coreCustomerUser = await sessionFromSupabaseAuth(params)\n  }\n  return coreCustomerUser\n}\n\nexport const parseErrorStringToErrorObject = (\n  errorString: string\n) => {\n  let [errorCode, ...errorJsonParts] = errorString.split(' ')\n  if (isNaN(Number(errorCode))) {\n    errorCode = 'Unknown'\n  }\n  let errorJson: Record<string, unknown> = {}\n  try {\n    errorJson = JSON.parse(errorJsonParts.join(' '))\n  } catch (e) {\n    errorJson = {\n      message: errorString,\n    }\n  }\n  return {\n    code: errorCode,\n    json: errorJson,\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,MAAM,yBAAyB,CACpC,WACG;AACH,MAAI,mBAA4C;AAChD,QAAM,UAAU,MAAM,OAAO,SAAS,KAAK;AAC3C,MAAI,mCAAS,MAAM;AACjB,QAAI,OAAO,SAAS,kBAAkB;AACpC,yBACE,MAAM,OAAO,SAAS,iBAAiB,OAAO;AAAA,IAClD,WAAW,CAAC,QAAQ,KAAK,OAAO;AAC9B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF,OAAO;AACL,yBAAmB;AAAA,QACjB,YAAY,QAAQ,KAAK;AAAA,QACzB,MAAM,QAAQ,KAAK,QAAQ;AAAA,QAC3B,OAAO,QAAQ,KAAK,SAAS;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEO,MAAM,0BAA0B,CACrC,WACG;AACH,MAAI,mBAA4C;AAChD,QAAM;AAAA,IACJ,MAAM,EAAE,KAAK;AAAA,EACf,IAAI,OAAO,MAAM,OAAO,aAAa,OAAO,GAAG,KAAK,QAAQ;AAC5D,MAAI,MAAM;AACR,uBAAmB;AAAA,MACjB,YAAY,KAAK;AAAA,MACjB,MAAM,KAAK,cAAc,QAAQ;AAAA,MACjC,OAAO,KAAK,SAAS;AAAA,IACvB;AAAA,EACF;AACA,SAAO;AACT;AAEO,MAAM,uBAAuB,CAClC,WACG;AACH,MAAI,mBAA4C;AAChD,MAAI,cAAc,QAAQ;AACxB,uBAAmB,MAAM,uBAAuB,MAAM;AAAA,EACxD;AAEA,MAAI,kBAAkB,QAAQ;AAC5B,uBAAmB,MAAM,wBAAwB,MAAM;AAAA,EACzD;AACA,SAAO;AACT;AAEO,MAAM,gCAAgC,CAC3C,gBACG;AACH,MAAI,CAAC,WAAW,GAAG,cAAc,IAAI,YAAY,MAAM,GAAG;AAC1D,MAAI,MAAM,OAAO,SAAS,CAAC,GAAG;AAC5B,gBAAY;AAAA,EACd;AACA,MAAI,YAAqC,CAAC;AAC1C,MAAI;AACF,gBAAY,KAAK,MAAM,eAAe,KAAK,GAAG,CAAC;AAAA,EACjD,SAAS,GAAG;AACV,gBAAY;AAAA,MACV,SAAS;AAAA,IACX;AAAA,EACF;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,EACR;AACF;","names":[]}
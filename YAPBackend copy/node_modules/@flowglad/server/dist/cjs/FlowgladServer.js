"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var FlowgladServer_exports = {};
__export(FlowgladServer_exports, {
  FlowgladServer: () => FlowgladServer
});
module.exports = __toCommonJS(FlowgladServer_exports);
var import_shared = require("@flowglad/shared");
var import_node = require("@flowglad/node");
const getSessionFromNextAuth = (params) => __async(void 0, null, function* () {
  let coreCustomerUser = null;
  const session = yield params.nextAuth.auth();
  if (session == null ? void 0 : session.user) {
    if (params.nextAuth.customerFromAuth) {
      coreCustomerUser = yield params.nextAuth.customerFromAuth(session);
    } else {
      if (!session.user.email) {
        throw new Error(
          "FlowgladError: NextAuth session has no email. Please provide an extractUserIdFromSession function to extract the userId from the session, or include email on your sessions."
        );
      }
      coreCustomerUser = {
        externalId: session.user.email,
        name: session.user.name || "",
        email: session.user.email || ""
      };
    }
  }
  return coreCustomerUser;
});
const getSessionFromNextAuth4 = (params) => __async(void 0, null, function* () {
  const session = yield params.nextAuth.auth();
  return session;
});
const sessionFromSupabaseAuth = (params) => __async(void 0, null, function* () {
  let coreCustomerUser = null;
  const {
    data: { user }
  } = yield (yield params.supabaseAuth.client()).auth.getUser();
  if (user) {
    coreCustomerUser = {
      externalId: user.id,
      name: user.user_metadata.name || "",
      email: user.email || ""
    };
  }
  return coreCustomerUser;
});
const sessionFromClerkAuth = (params) => __async(void 0, null, function* () {
  let coreCustomerUser = null;
  const session = yield params.clerk.currentUser();
  if (params.clerk.customerFromCurrentUser && session) {
    coreCustomerUser = yield params.clerk.customerFromCurrentUser(session);
  } else if (session) {
    coreCustomerUser = {
      externalId: session.id,
      name: session.firstName || "",
      email: session.emailAddresses[0].emailAddress || ""
    };
  }
  return coreCustomerUser;
});
const getSessionFromParams = (params) => __async(void 0, null, function* () {
  let coreCustomerUser = null;
  if ("nextAuth" in params) {
    coreCustomerUser = yield getSessionFromNextAuth(params);
  } else if ("supabaseAuth" in params) {
    coreCustomerUser = yield sessionFromSupabaseAuth(params);
  } else if ("clerk" in params) {
    coreCustomerUser = yield sessionFromClerkAuth(params);
  } else if (params.getRequestingCustomer) {
    coreCustomerUser = yield params.getRequestingCustomer();
  }
  return coreCustomerUser;
});
class FlowgladServer {
  constructor(createHandlerParams) {
    this.getRequestingCustomerId = () => __async(this, null, function* () {
      if (this.createHandlerParams.getRequestingCustomer) {
        const customer = yield this.createHandlerParams.getRequestingCustomer();
        if (customer) {
          return customer.externalId;
        }
      }
      const session = yield getSessionFromParams(
        this.createHandlerParams
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return session.externalId;
    });
    this.getSession = () => __async(this, null, function* () {
      return getSessionFromParams(this.createHandlerParams);
    });
    this.getBilling = () => __async(this, null, function* () {
      var _a;
      const customer = yield this.findOrCreateCustomer();
      const rawBilling = yield this.flowgladNode.customers.retrieveBilling(
        customer.externalId
      );
      const currentSubscriptionsWithExperimental = (_a = rawBilling.currentSubscriptions) != null ? _a : [];
      return __spreadProps(__spreadValues({}, rawBilling), {
        checkFeatureAccess: (0, import_shared.constructCheckFeatureAccess)(
          currentSubscriptionsWithExperimental
        ),
        checkUsageBalance: (0, import_shared.constructCheckUsageBalance)(
          currentSubscriptionsWithExperimental
        ),
        getProduct: (0, import_shared.constructGetProduct)(rawBilling.catalog),
        getPrice: (0, import_shared.constructGetPrice)(rawBilling.catalog)
      });
    });
    this.findOrCreateCustomer = () => __async(this, null, function* () {
      let customer = null;
      try {
        const getResult = yield this.getCustomer();
        customer = getResult.customer;
      } catch (error) {
        if (error.error.code === "NOT_FOUND") {
          const session = yield getSessionFromParams(
            this.createHandlerParams
          );
          if (!session) {
            throw new Error("User not authenticated");
          }
          const createResult = yield this.createCustomer({
            customer: {
              email: session.email,
              name: session.name,
              externalId: session.externalId
            }
          });
          customer = createResult.data.customer;
        } else {
          throw error;
        }
      }
      if (!customer) {
        throw new Error("Customer not found");
      }
      return customer;
    });
    this.getCustomer = () => __async(this, null, function* () {
      const session = yield getSessionFromParams(
        this.createHandlerParams
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return this.flowgladNode.customers.retrieve(session.externalId);
    });
    this.createCustomer = (params) => __async(this, null, function* () {
      return this.flowgladNode.customers.create(params);
    });
    this.createCheckoutSession = (params) => __async(this, null, function* () {
      const session = yield getSessionFromParams(
        this.createHandlerParams
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return this.flowgladNode.checkoutSessions.create({
        checkoutSession: __spreadProps(__spreadValues({}, params), {
          customerExternalId: session.externalId
        })
      });
    });
    this.updateCustomer = (params) => __async(this, null, function* () {
      const session = yield getSessionFromParams(
        this.createHandlerParams
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return this.flowgladNode.customers.update(
        session.externalId,
        params
      );
    });
    this.createAddPaymentMethodCheckoutSession = (params) => __async(this, null, function* () {
      return this.createCheckoutSession(__spreadProps(__spreadValues({}, params), {
        type: "add_payment_method"
      }));
    });
    this.createProductCheckoutSession = (params) => __async(this, null, function* () {
      return this.createCheckoutSession(__spreadProps(__spreadValues({}, params), { type: "product" }));
    });
    this.cancelSubscription = (params) => __async(this, null, function* () {
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(params.id);
      if (subscription.status === "canceled") {
        throw new Error("Subscription is already canceled");
      }
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      return this.flowgladNode.subscriptions.cancel(params.id, {
        cancellation: params.cancellation
      });
    });
    this.createSubscription = (params) => __async(this, null, function* () {
      var _a;
      const customer = yield this.findOrCreateCustomer();
      const rawParams = __spreadProps(__spreadValues({}, params), {
        quantity: (_a = params.quantity) != null ? _a : 1,
        customerId: customer.id
      });
      return this.flowgladNode.subscriptions.create(rawParams);
    });
    /**
     * Create a usage event for a customer.
     * NOTE: this method makes two API calls, including one to get the customer.
     * If you are to create usages en masse with minimum latency,
     * you should use `FlowgladServerAdmin.createUsageEvent` instead.
     * @param params - The parameters for the usage event.
     * @returns The created usage event.
     */
    this.createUsageEvent = (params) => __async(this, null, function* () {
      const parsedParams = import_shared.createUsageEventSchema.parse(params);
      return this.flowgladNode.usageEvents.create({
        usageEvent: __spreadProps(__spreadValues({}, parsedParams), {
          usageDate: parsedParams.usageDate || void 0
        })
      });
    });
    this.getCatalog = () => __async(this, null, function* () {
      const billing = yield this.getBilling();
      return { catalog: billing.catalog };
    });
    this.createHandlerParams = createHandlerParams;
    this.flowgladNode = new import_node.Flowglad({
      apiKey: createHandlerParams.apiKey,
      baseURL: createHandlerParams.baseURL
    });
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FlowgladServer
});
//# sourceMappingURL=FlowgladServer.js.map
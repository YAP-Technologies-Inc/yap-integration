{"version":3,"sources":["../../src/FlowgladServer.ts"],"sourcesContent":["import {\n  type CancelSubscriptionParams,\n  type CreateCheckoutSessionParams,\n  type CreateSubscriptionParams,\n  type CreateUsageEventParams,\n  createUsageEventSchema,\n  constructCheckFeatureAccess,\n  constructCheckUsageBalance,\n  type CreateAddPaymentMethodCheckoutSessionParams,\n  type CreateProductCheckoutSessionParams,\n  type BillingWithChecks,\n  SubscriptionExperimentalFields,\n  constructGetProduct,\n  constructGetPrice,\n} from '@flowglad/shared'\nimport {\n  type ClerkFlowgladServerSessionParams,\n  type CoreCustomerUser,\n  type FlowgladServerSessionParams,\n  type NextjsAuthFlowgladServerSessionParams,\n  type SupabaseFlowgladServerSessionParams,\n} from './types'\n\nimport { Flowglad as FlowgladNode } from '@flowglad/node'\n\nconst getSessionFromNextAuth = async (\n  params: NextjsAuthFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.nextAuth.auth()\n  if (session?.user) {\n    if (params.nextAuth.customerFromAuth) {\n      coreCustomerUser =\n        await params.nextAuth.customerFromAuth(session)\n    } else {\n      if (!session.user.email) {\n        throw new Error(\n          'FlowgladError: NextAuth session has no email. Please provide an extractUserIdFromSession function to extract the userId from the session, or include email on your sessions.'\n        )\n      }\n      coreCustomerUser = {\n        externalId: session.user.email,\n        name: session.user.name || '',\n        email: session.user.email || '',\n      }\n    }\n  }\n  return coreCustomerUser\n}\n\nconst getSessionFromNextAuth4 = async (\n  params: NextjsAuthFlowgladServerSessionParams\n) => {\n  const session = await params.nextAuth.auth()\n  return session\n}\n\nconst sessionFromSupabaseAuth = async (\n  params: SupabaseFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const {\n    data: { user },\n  } = await (await params.supabaseAuth.client()).auth.getUser()\n  if (user) {\n    coreCustomerUser = {\n      externalId: user.id,\n      name: user.user_metadata.name || '',\n      email: user.email || '',\n    }\n  }\n  return coreCustomerUser\n}\n\nconst sessionFromClerkAuth = async (\n  params: ClerkFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.clerk.currentUser()\n  if (params.clerk.customerFromCurrentUser && session) {\n    coreCustomerUser =\n      await params.clerk.customerFromCurrentUser(session)\n  } else if (session) {\n    coreCustomerUser = {\n      externalId: session.id,\n      name: session.firstName || '',\n      email: session.emailAddresses[0].emailAddress || '',\n    }\n  }\n  return coreCustomerUser\n}\n\nconst getSessionFromParams = async (\n  params: FlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  if ('nextAuth' in params) {\n    coreCustomerUser = await getSessionFromNextAuth(params)\n  } else if ('supabaseAuth' in params) {\n    coreCustomerUser = await sessionFromSupabaseAuth(params)\n  } else if ('clerk' in params) {\n    coreCustomerUser = await sessionFromClerkAuth(params)\n  } else if (params.getRequestingCustomer) {\n    coreCustomerUser = await params.getRequestingCustomer()\n  }\n  return coreCustomerUser\n}\n\nexport class FlowgladServer {\n  private createHandlerParams: FlowgladServerSessionParams\n  private flowgladNode: FlowgladNode\n  constructor(createHandlerParams: FlowgladServerSessionParams) {\n    this.createHandlerParams = createHandlerParams\n    this.flowgladNode = new FlowgladNode({\n      apiKey: createHandlerParams.apiKey,\n      baseURL: createHandlerParams.baseURL,\n    })\n  }\n\n  public getRequestingCustomerId = async (): Promise<string> => {\n    if (this.createHandlerParams.getRequestingCustomer) {\n      const customer =\n        await this.createHandlerParams.getRequestingCustomer()\n      if (customer) {\n        return customer.externalId\n      }\n    }\n    const session = await getSessionFromParams(\n      this.createHandlerParams\n    )\n    if (!session) {\n      throw new Error('User not authenticated')\n    }\n    return session.externalId\n  }\n\n  public getSession = async (): Promise<CoreCustomerUser | null> => {\n    return getSessionFromParams(this.createHandlerParams)\n  }\n\n  public getBilling = async (): Promise<BillingWithChecks> => {\n    const customer = await this.findOrCreateCustomer()\n    const rawBilling =\n      await this.flowgladNode.customers.retrieveBilling(\n        customer.externalId\n      )\n    const currentSubscriptionsWithExperimental =\n      (rawBilling.currentSubscriptions ?? []) as unknown as {\n        id: string\n        experimental: SubscriptionExperimentalFields\n      }[]\n    return {\n      ...rawBilling,\n      checkFeatureAccess: constructCheckFeatureAccess(\n        currentSubscriptionsWithExperimental\n      ),\n      checkUsageBalance: constructCheckUsageBalance(\n        currentSubscriptionsWithExperimental\n      ),\n      getProduct: constructGetProduct(rawBilling.catalog),\n      getPrice: constructGetPrice(rawBilling.catalog),\n    }\n  }\n\n  public findOrCreateCustomer = async (): Promise<\n    FlowgladNode.Customers.CustomerRetrieveResponse['customer']\n  > => {\n    let customer:\n      | FlowgladNode.Customers.CustomerRetrieveResponse['customer']\n      | null = null\n    try {\n      const getResult = await this.getCustomer()\n      customer = getResult.customer\n    } catch (error) {\n      if ((error as any).error.code === 'NOT_FOUND') {\n        const session = await getSessionFromParams(\n          this.createHandlerParams\n        )\n        if (!session) {\n          throw new Error('User not authenticated')\n        }\n        const createResult = await this.createCustomer({\n          customer: {\n            email: session.email,\n            name: session.name,\n            externalId: session.externalId,\n          },\n        })\n        customer = createResult.data.customer\n      } else {\n        throw error\n      }\n    }\n    if (!customer) {\n      throw new Error('Customer not found')\n    }\n    return customer\n  }\n\n  public getCustomer =\n    async (): Promise<FlowgladNode.Customers.CustomerRetrieveResponse> => {\n      const session = await getSessionFromParams(\n        this.createHandlerParams\n      )\n      if (!session) {\n        throw new Error('User not authenticated')\n      }\n      return this.flowgladNode.customers.retrieve(session.externalId)\n    }\n  public createCustomer = async (\n    params: FlowgladNode.Customers.CustomerCreateParams\n  ): Promise<FlowgladNode.Customers.CustomerCreateResponse> => {\n    return this.flowgladNode.customers.create(params)\n  }\n  public createCheckoutSession = async (\n    params: CreateCheckoutSessionParams\n  ): Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse> => {\n    const session = await getSessionFromParams(\n      this.createHandlerParams\n    )\n    if (!session) {\n      throw new Error('User not authenticated')\n    }\n    return this.flowgladNode.checkoutSessions.create({\n      checkoutSession: {\n        ...params,\n        customerExternalId: session.externalId,\n      },\n    })\n  }\n\n  public updateCustomer = async (\n    params: FlowgladNode.Customers.CustomerUpdateParams\n  ): Promise<FlowgladNode.Customers.CustomerUpdateResponse> => {\n    const session = await getSessionFromParams(\n      this.createHandlerParams\n    )\n    if (!session) {\n      throw new Error('User not authenticated')\n    }\n    return this.flowgladNode.customers.update(\n      session.externalId,\n      params\n    )\n  }\n\n  public createAddPaymentMethodCheckoutSession = async (\n    params: CreateAddPaymentMethodCheckoutSessionParams\n  ): Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse> => {\n    return this.createCheckoutSession({\n      ...params,\n      type: 'add_payment_method',\n    })\n  }\n\n  public createProductCheckoutSession = async (\n    params: CreateProductCheckoutSessionParams\n  ): Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse> => {\n    return this.createCheckoutSession({ ...params, type: 'product' })\n  }\n\n  public cancelSubscription = async (\n    params: CancelSubscriptionParams\n  ): Promise<FlowgladNode.Subscriptions.SubscriptionCancelResponse> => {\n    const { subscription } =\n      await this.flowgladNode.subscriptions.retrieve(params.id)\n    if (subscription.status === 'canceled') {\n      throw new Error('Subscription is already canceled')\n    }\n    const { customer } = await this.getCustomer()\n    if (subscription.customerId !== customer.id) {\n      throw new Error('Subscription is not owned by the current user')\n    }\n    return this.flowgladNode.subscriptions.cancel(params.id, {\n      cancellation:\n        params.cancellation as FlowgladNode.Subscriptions.SubscriptionCancelParams['cancellation'],\n    })\n  }\n\n  public createSubscription = async (\n    params: Omit<CreateSubscriptionParams, 'customerId'>\n  ): Promise<FlowgladNode.Subscriptions.SubscriptionCreateResponse> => {\n    const customer = await this.findOrCreateCustomer()\n    const rawParams = {\n      ...params,\n      quantity: params.quantity ?? 1,\n      customerId: customer.id,\n    }\n    // const parsedParams = createSubscriptionSchema.parse(rawParams)\n    // @ts-ignore\n    return this.flowgladNode.subscriptions.create(rawParams)\n  }\n\n  /**\n   * Create a usage event for a customer.\n   * NOTE: this method makes two API calls, including one to get the customer.\n   * If you are to create usages en masse with minimum latency,\n   * you should use `FlowgladServerAdmin.createUsageEvent` instead.\n   * @param params - The parameters for the usage event.\n   * @returns The created usage event.\n   */\n  public createUsageEvent = async (\n    params: CreateUsageEventParams\n  ): Promise<FlowgladNode.UsageEvents.UsageEventCreateResponse> => {\n    const parsedParams = createUsageEventSchema.parse(params)\n    return this.flowgladNode.usageEvents.create({\n      usageEvent: {\n        ...parsedParams,\n        usageDate: parsedParams.usageDate || undefined,\n      },\n    })\n  }\n\n  public getCatalog =\n    async (): Promise<FlowgladNode.Catalogs.CatalogRetrieveResponse> => {\n      const billing = await this.getBilling()\n      return { catalog: billing.catalog }\n    }\n}\n"],"mappings":"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","names":[]}